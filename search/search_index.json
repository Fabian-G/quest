{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>To start using Quest you don't necessarily need any configuration. That is, if all you need is a simple CLI to interface with your todo.txt without any special features.</p> <p>In most cases you will want a config though. Since there is probably a bit of a learning curve for this, Quest comes with a few presets. Therefore, after installing Quest the first thing you will want to do is to choose your preset by running: <pre><code>quest init\n</code></pre> If you don't follow a particular methodology (like GTD) it is recommended to choose  extended todo.txt. This preset comes with all advanced features enabled (like recurrent tasks), but other than that it is pretty minimal.</p>"},{"location":"#addinglistingcompletingediting-tasks","title":"Adding/Listing/Completing/Editing tasks","text":"<p>Adding a new task can be done by using the <code>add</code> command. Every remaining argument will be considered part of the task description. <pre><code>quest add Do the dishes\n</code></pre></p> <p>To list tasks, simply run <code>quest</code> without any arguments. You can also add keywords to search for, <code>quest -- dish</code> will only list tasks containing the substring \"dish\".</p> <p>To complete a task you can use the <code>complete</code> command, which takes a list  of selectors (e.g. words to search for) as well. If you know you want to complete a task that contains the word \"dish\" simply run this. <pre><code>quest complete dish\n</code></pre> If multiple tasks contain the word dish Quest will ask you which tasks you mean.</p> <p>To edit a task in your editor you'll want to use the <code>edit</code> command. <pre><code>quest edit dish\n</code></pre></p>"},{"location":"#updating-projectscontextstags","title":"Updating Projects/Contexts/Tags","text":"<p>Words in a task description that are prefixed by an @ symbol are considered contexts. If a word is prefixed by a + Symbol it is considered a project. The <code>set</code> and <code>unset</code> commands are used to manage these types of metadata. For example to add the task on line 3 to the project foo, one would run: <pre><code>quest set +foo on 3\n</code></pre> and to remove it from the project: <pre><code>quest unset +foo on 3\n</code></pre></p> <p>Tags are key-value pairs that carry metadata for the task. Commonly this is used to carry due dates: <pre><code>quest set due:2024-12-12 on 3\n</code></pre> or to make a task recurrent: <pre><code>quest set t:2024-12-10 rec:1y on 3\n</code></pre></p>"},{"location":"#where-to-go-from-here","title":"Where to go from here","text":"<p>With these few commands you can probably get started already.  At some point you will want to look into how to define views for which you will need at least a basic understanding of the query language. For convenience you might also want to look into tag expansions.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>This annotated example configuration shows all available options. Every option is set to their default. If the default is empty you will find  another (commented out) example line right above it.</p> <pre><code># The Path to the todo.txt quest should use by default. \n# Can be overriden with the -f option\ntodo-file = \"$HOME/.local/share/quest/todo.txt\"\n\n# The Path where quest should store completed items. \n# Done tasks are NOT moved automatically, but only when using the archive command.\ndone-file = \"$HOME/.local/share/quest/done.txt\"\n\n# When set to a value &gt; 0 quest will make a backup of the todo.txt/done.txt \n# whenever it is changed.\n# For example: Setting this to 10 will keep at most 10 backups, always deleting the oldest\n# after each change\nbackup = 0\n\n# If set to false Tags that are not declared in the tags section will emit an \n# error if encountered in the todo.txt\nunknown-tags = true\n\n# A list of tags that should be removed from a task upon completion\n# clear-on-done = [ \"do\" ]\nclear-on-done = []\n\n# A list of style definitions that should be applied to a whole line in the task \n# view.\n# styles = [\n#   { if = 'blocked', fg = \"3\" },\n# ]\nsyles = []\n\n# The quest-score is a value calculated based on the urgency\n# and priority of a task.\n# High urgency and high priority results in a high quest-score.\n[quest-score]\n# The date tags that define the urgency of a task.\n# Might also be offset by a duration value.\n# Only the first existing tag is considered for urgency calculation.\nurgency-tags = [ \"due\" ]\n\n# When a task will start to be considered as urgent (in days). \nurgency-begin = 90 \n\n# If the urgency-tag is unset on a task the urgency will be calculated by\n# adding this duration to the creation date.\n# This is useful to avoid low priority tasks being left undone forever.\n# Setting this to \"0d\" disables this feature.\nurgency-default = \"0d\"\n\n# The minimal priority. All lower priorities are considered unimportant.\nmin-priority = \"E\" \n\n# Properties for configuring the timewarrior integration.\n# The Projects, Contexts and description are used for tags\n[tracking]\n# The tag that should trigger tracking\n# Setting this to \"\" disables this feature\n# tag = \"tr\"\ntag = \"\"\n\n# Which todo.txt tags to include as timewarrior tags\n# include-tags = [\"ticket\"]\ninclude-tags = []\n\n# If the + should be removed from projects\ntrim-project-prefix = false \n# If the @ should be removed from contexts\ntrim-context-prefix = false\n\n# Tag configuration for the recurrence feature\n[recurrence]\n# Duration tag that defines the recurrence interval\n# Setting this to \"\" disables recurrence\n# rec-tag = \"rec\"\nrec-tag = \"\" \n\n# Date tag that defines the due date\ndue-tag = \"due\" \n\n# Date tag that defined the threshold date\nthreshold-tag = \"t\" \n\n# When this option is set to true an item that is spawned by completing a\n# recurrent item will be assigned the same priority as the original.\npreserve-priority = false\n\n# Configures quest's notes feature, which allows you to add \n# multi line notes to your todo.txt items\n[notes]\n# The tag which should store the reference to the note id\n# Setting this to \"\" disables this feature\n# tag = \"n\" \ntag = \"\"\n\n# The length of the id.\nid-length = 4 \n\n# Directory where notes should be stored.\n# The base directory will be created if necessary, parents are not.\n# Note that this directory should be exclusively used by quest,\n# files in that directory that were not created by quest may be\n# deleted without warning (in particular by the \"notes clean\" command)\ndir = \"$HOME/.local/share/quest/notes\"\n\n\n# List of tag definitions to enable tag expansions and styling\n[tags]\n# [tags.due]\n# # type of the tag. One of \"string\", \"date\", \"duration\", \"int\"\n# type = \"date\" \n\n# # If the tag is a date tag and humanize = true it will be output in a human \n# # friendly format\n# humanize = true \n\n# # Per tag style definitions. This will color only the corresponding cell.\n# styles = [\n#   { if = 'date(tag(it, \"due\"), maxDate) &lt;= today + 1d', fg = \"1\" },\n#   { if = 'date(tag(it, \"due\"), maxDate) &lt;= today + 3d', fg = \"6\" }\n# ]\n\n# Default view definition.\n# This has 2 purposes. \n# 1. It is the view that is displayed when no view is specified.\n# 2. The values set here serve as the defaults for other views\n[default-view]\n# The query for this view.\n# Usually you'll want the default-view query to match all (or all pending) tasks.\n# Making this too restrictive may be inconvenient sometimes.\nquery = \"\"\n\n# A list of columns to be included in the output\nprojection = [ \"line\", \"done\", \"priority\", \"completion\", \"creation\", \"projects\", \"contexts\", \"tags\", \"description\"]  \n\n# A list of tags, projects and contexts that should be removed \n# from the description column.\n# This is useful to avoid displaying redundant information. \n# If we already have a whole column dedicated to projects\n# we won\"t need the project displayed inside the description column as well.\n# clean = [\"@ALL\",\"+ALL\"]\nclean = []\n\n# Whether or not this view should be opened in interactive mode with live reload\ninteractive = false\n\n# When the user adds an item through this view the configured prefix gets \n# automatically prepended.\n# add-prefix = '@inbox'\nadd-prefix = ''\n\n# When the user adds an item through this view the configured suffix gets \n# automatically appended.\n# add-suffix = '@inbox'\nadd-suffix = ''\n\n# Limits the amount of tasks that will be outputted. \n# Set to -1 to show all tasks.\nlimit = -1\n\n# A view definition with the name inbox.\n# [views.inbox]\n# # This is the message that will be shown when running quest help.\n# # Should describe the purpose of this view.\n# descripition = \"Lists all tasks that match the view query\"\n# query = '!done &amp;&amp; @inbox'\n# sort = [\"+creation\",\"+description\"]\n# clean = [\"@inbox\"]\n# projection = [\"line\",\"creation\",\"description\"]\n\n# [[macro]]\n# # The name of the macro\n# name = \"blocked\" \n# \n# # The arguments of the macro\n# args = [\"item\"] \n# \n# # The expected result type of the macro\n# result = \"bool\" \n# \n# # The actual query that the macro performs\n# query = '!(tag(arg0, \"after\", \"\") == \"\") &amp;&amp; (exists pre in items: tag(pre, \"id\", \"\") == tag(arg0, \"after\") &amp;&amp; !done(pre))'\n# \n# # Whether or not we want to enable the special it-injection syntax for this macro, \n# # so that we can write blocked, instead of blocked(it)\n# inject-it = true\n</code></pre>"},{"location":"editing/","title":"Editing tasks","text":""},{"location":"editing/#basic-commands","title":"Basic Commands","text":"<p>The most basic way of modifying your todo.txt is by using the commands <code>add</code>, <code>complete</code>, <code>prioritize</code> and <code>remove</code>. With the exception of <code>add</code> these commands will take any number of selectors  (as described in Selection). By default these commands are designed with the assumption that your intention is to operate on a single task. Therefore, if your selection matches multiple  tasks you will be presented a selection prompt. This makes it safe to use very broad selectors.  For example, let's say you just finished doing the laundry. Now, to mark the corresponding item as completed in Quest, you could run <code>quest</code>, figure out the  line number of the task and the run <code>quest complete &lt;line&gt;</code>. However, we know that the task probably contains the word laundry. We can therefore just run: <pre><code>~ \u276f quest complete laundry\nCompleted item #113: Do the laundry\n</code></pre> This is safe, because if there were multiple items containing the word \"laundry\" we would have been prompted to select one (or more).</p>"},{"location":"editing/#managing-projectscontextstags","title":"Managing Projects/Contexts/Tags","text":"<p>The <code>set</code> and <code>unset</code> commands can be used to add or remove projects/contexts/tags. Just as the \"Basic Commands\" these take a list of selectors as arguments, but they also need a list of projects, contexts or tags to set or unset. These two lists will be separated by the <code>on</code> keyword. Examples:</p> <pre><code># Sets the do tag to the date of today on tasks 1-4\nquest set do:today on 1,2,3,4\n# Sets @foo +bar t:tomorrow on tasks 1,2,3,4,6,7, \n# which are also in the baz context\nquest set @foo +bar t:tomorrow on 1-4,6-7 @baz\n</code></pre> <p>The tags/projects/contexts added with the <code>set</code> command will always be appended to the description. If a tag already exists its value will be changed in place. If a project or context already exists, it will be left untouched.</p> <p>Note that when unsetting tags you specify only the tag name (not the value):</p> <pre><code>quest unset due on 4\n</code></pre>"},{"location":"editing/#editing-sublists","title":"Editing Sublists","text":"<p>One powerful feature of Quest is the ability to edit sublists of  your todo.txt. Effectively, what this does is:</p> <ol> <li>Find tasks that match your query.</li> <li>Write them to a temporary file for you to edit.</li> <li>Wait for you to make your changes.</li> <li>Validate the results.</li> <li>Merge the changes back into the original todo.txt</li> </ol> <p>The edit command fully supports all advanced features of Quest, like recurrence, tag expansions and validations. You can also remove tasks by simply removing lines and add tasks by adding lines. There are only 3 minor things to keep in mind when editing your todos this way:</p> <ol> <li>Reordering the tasks in the temporary file will have no effect.</li> <li>Quest will add a special <code>quest-object-id</code> tag to the todo items in the temporary file.     This is used to associate the changed state with the previous states stored in memory to     trigger recurrence and other change based behaviour correctly.      If you remove such a tag, this will be handled like a removal of the old task followed by an     addition. </li> <li>The intention of this feature is to make quick edits and then merge them back.      You should not keep the temporary file open in the background for long stretches of time,     because if the todo.txt is written to in the meantime Quest will not     be able to merge your changes back into the changed file. Your changes will not be lost     in this case, but you will have to merge them manually.</li> </ol> <p>It is also recommended to use this feature with an editor that supports todo.txt.  Like neovim with a todo.txt plugin for example.</p>"},{"location":"notes/","title":"Note Taking","text":"<p>One major limitation of todo.txt is that todo items are always single line items. And this is fine most of the time, because the todo item should serve as a simple reminder on what to do and not how to do it. Sometimes though, we do want to attach more information to a todo item  (like progress notes, problems encountered...) and this is what the <code>notes</code> view command enables us to do.</p> <p>Basically the <code>notes</code> view command creates a separate markdown file with a unique id and attaches it to a task by setting a tag to that id.</p> <p>To start using notes you just have to tell quest which tag to use:</p> <pre><code>[notes]\ntag = \"n\"\n</code></pre> <p>Now you can run <code>quest notes 42</code> to open the note file for task 42 in your editor. The note will be created in <code>$HOME/.local/share/quest/notes</code> by default.  To change this set the <code>dir</code> property in the <code>[notes]</code> section appropriately.</p> <p>As always the command takes any type of selectors as described in Selecting Tasks. However, <code>notes</code> enforces that your selection matches a single task. If it matches multiple task you will be prompted to select a match.</p>"},{"location":"notes/#id-generation","title":"Id generation","text":"<p>By default <code>notes</code> generates 4 character long alphanumeric ids.  Which should be a good compromise between length of id and amount of available  ids. If, for whatever reason, you want to change that default set the <code>id-length</code> property in the <code>[notes]</code> section to whatever value you like.</p> <p>In the unlikely event that you run out of ids you can try running <code>quest notes clean</code>,  which will remove all notes that are not referenced from any item (todo.txt or done.txt). </p>"},{"location":"recurrence/","title":"Recurrence","text":"<p>The minimal configuration to enable recurrence is:</p> <pre><code>[recurrence]\nrec-tag = \"rec\"\n</code></pre> <p>This configuration will use the <code>rec</code> tag to determine the recurrence interval and the <code>t</code> and <code>due</code> tag to determine the threshold and due-tag.</p> <p>This implementation of recurring tasks aims to be compatible with other todo.txt clients like pter and simpletask.  So for further details checkout the pter docs</p>"},{"location":"score/","title":"Quest Score","text":"<p>Note: The Quest Score is more or less experimental  in the sense that it is likely to change in the future.</p> <p>The Quest Score aims to provide some general guideline on which task to do next. It is loosely based on the concept of the Eisenhower Matrix, which sorts  a task in a two dimensional matrix. The first dimension is the urgency and the second dimension the importance.</p> <p>The Quest Score measures urgency in terms of a configurable date (usually the date associated  with the due tag) and the closer this date gets the higher is the urgency.</p> <p>The importance on the other hand is measured by the priority of a task. A higher priority (closer to A) means the task is more important.</p> <p>After that Quest will take this two dimensional vector and try to calculate  a scalar value between 0 and 10 from this in a meaningful way.  Currently it does so by calculating the root mean square.</p> <p>The Quest Score comes with a sensible default configuration. So to use it, just put <code>score</code> inside some of your projections.</p>"},{"location":"score/#make-old-tasks-urgent","title":"Make Old Tasks Urgent","text":"<p>You might want to let tasks gain slightly in urgency the older they get too avoid  having them on your list forever. This is what the <code>urgency-default</code> option in the <code>[quest-score]</code> section is for. If the task does not have any of the configured <code>urgency-tags</code> and the <code>urgency-default</code> is set to a non-zero duration value, Quest will consider the creation date plus the  <code>urgency-default</code> as the urgency date. This has one minor drawback though. Imagine you know 6 months in advance that you need to bake a cake. Assuming you use the t tag according to the convention, you would probably do: <pre><code>quest add bake a cake t:6m\n</code></pre> This new task will have the creation date of today, so when it shows up in 6 months it will have a very high Quest Score, which is not what we want.</p> <p>To fix this we can add the t tag to the list of urgency tags, but offset by some amount of time.</p> <pre><code>[quest-score]\nurgency-tags = [ \"due\", \"t+2m\" ]\nurgency-default = \"2m\"\n</code></pre> <p>Now Quest will first consider the due tag and if that is not set it will consider the t tag offset by two months. So in our example the \"bake a cake\" task will have maximal urgency 2 months after it shows up.</p>"},{"location":"selection/","title":"Selecting Tasks","text":"<p>When selecting tasks you can decide between 3 options: Range Query, String Search or Quest Query Language (QQL). QQL can do everything the other two can do (and more), but might be slightly less convenient. You can specify which type of query your are using on the command line with the <code>-q</code>, <code>-r</code> and <code>-w</code> options.  If you don't and simply pass your query as an argument, quest will try to guess what type of query you are using. \"Guessing\" means in this case that it tries to parse it as a QQL query, if that fails it tries to parse it as a range query and if that fails it finally treats it like a string search. While this is convenient most of the time, this can behave unexpectedly if you are intending to write a QQL query, but have a syntax error, which is then silently ignored.  In that case you should be explicit about the query type and use <code>-q</code>.</p>"},{"location":"selection/#range-query","title":"Range Query","text":"<p>You can select items by their line number using simple range expressions like:</p> <ul> <li><code>1,2,3</code>: selects tasks 1, 2 and 3</li> <li><code>1-3</code>: Also selects tasks 1, 2 and 3</li> <li><code>1,3-</code>: Selects tasks 1 and all tasks after and including task 3</li> </ul>"},{"location":"selection/#string-search","title":"String search","text":"<p>The string search (usually <code>-w</code> flag in the CLI) will do a simple case-insensitive substring search in the task description.</p>"},{"location":"selection/#quest-query-language-qql","title":"Quest Query Language (QQL)","text":"<p>Quest comes with a powerful query language, which is based on first-order logic (FOL).  If you are already familiar with FOL you should be able to get started in no time. If not, there may be a learning curve if you want to write more advanced queries, but the basics should be pretty straightforward.</p> <p>A basic QQL query will look like this: <pre><code>!done(it) &amp;&amp; priority(it) &gt;= prioC &amp;&amp; substring(description(it), \"foo\")\n</code></pre> Quest will run your query against each item in the list and checks if it matches.  The query will receive the current item through the <code>it</code> variable. Therefore the above query matches all items that are not done, have a priority higher or equal to (C) and contain the word \"foo\" in the description.</p>"},{"location":"selection/#syntax-and-semantics","title":"Syntax and Semantics","text":"<p>The syntax will not be explained in great detail here, because it is basically what you would expect from any programming language.</p> <p>A primary expression can either be a function call of the form <code>function(args)</code> (see Available Function),  an integer value, a boolean value (<code>true</code> or <code>false</code>), a string literal (with double-quotes <code>\"hello world\"</code>), a duration literal (see Durations) or a constant (see Constant).</p> <p>There are the following boolean operators: <code>!</code> (not), <code>&amp;&amp;</code> (and), <code>||</code> (or), <code>-&gt;</code> (implication, \"if a then b\" and equivalent to \"!a || b\").  You can always use parentheses, but if you don't, the order they are listed here is the order of precedence.</p> <p>Example: <pre><code>true -&gt; false || true &amp;&amp; !false // equivalent to (true -&gt; (false || (true &amp;&amp; (!false))))\n</code></pre></p> <p>To compare values you can use the usual <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>&gt;=</code> and <code>&gt;</code> operators.  You can compare dates, integers, strings, durations, boolean values and tasks, but the last two can only be compared with <code>==</code>. If you want to check for inequality you can use <code>!(a == b)</code>.</p> <p>Example: <pre><code>ymd(2022, 2, 2) &gt;= ymd(2021,2,2) &amp;&amp; 5 &lt; 6 &amp;&amp; \"foo\" &gt; \"bar\" // evaluates to true\n</code></pre></p> <p>QQL also supports the numeric operators <code>+</code> and <code>-</code>.  Obviously this works on the int type (<code>5+5==10</code> evaluates to true), but you can also use this for dates and durations (<code>ymd(2022,2,2)+5d==ymd(2022,2,7)</code>).</p> <p>Finally you can use the quantifiers <code>exists</code> and <code>forall</code> over any collection. The basic syntax is: <code>quantifier x in collection: expression</code>. Where quantifier is either exists or forall, x is an arbitrary variable name and collection is any collection. <code>exists x in collection: expression</code> will evaluate to true if there is at least one item in the collection so that the expression evaluates to true (with the variable <code>x</code> set to that particular item). Similarly <code>forall x in collection: expression</code> evaluates to true if <code>expression</code> is true for all items in the collection. There are multiple ways to obtain a collection to quantify over:</p> <ol> <li>Use the <code>items</code> constant, which contains all items in your list: <code>forall item in items: done(item)</code> (evaluates to true if all items in the list are done)</li> <li>Use <code>projects</code> or <code>contexts</code> function: <code>exists proj in projects(it): proj == \"+foo\"</code> (evaluates to true if <code>it</code> is in the project \"+foo\")</li> <li>Use <code>list</code> to transform any string (for example from a tag) to a list: <code>exists num in list(tag(it, \"favorite-numbers\")): num == \"2\"</code> (matches for example <code>favorite-numbers:1,2,3</code>)</li> </ol> <p>A common pattern is to make a statement about all items that fulfil a certain precondition. This is where the implication operator comes in handy.  For example if we wanted to check if <code>it</code> is the last not done item in a group of items we could write: <code>!done(it) &amp;&amp; forall other in items: tag(it, \"group\") == tag(other, \"group\") &amp;&amp; !(it == other) -&gt; done(other)</code> \"match it if: it is not done and all other items that have the same group-tag as it are done\".</p>"},{"location":"selection/#syntactic-sugar","title":"Syntactic Sugar","text":"<p>Function calls come with two rules that make the average usage of QQL a little more convenient:</p> <ol> <li>If a function call requires an item as an argument and it is omitted, it will simply be replaced by it. For example writing <code>done()</code> is the same as <code>done(it)</code></li> <li>If the argument list is empty, the parentheses can be omitted: <code>done()</code> is the same as writing <code>done</code></li> </ol> <p>For example: <code>!done &amp;&amp; priority &gt;= prioC</code> matches all tasks that are not done and have a priority of at least (C).</p> <p>Another extension to the syntax is that you can check if it is in a specific (sub) project by using the project matcher syntax: <code>+foo</code>. The same is possible for contexts with <code>@foo</code>.</p> <p>Example: <code>@foo &amp;&amp; +bar</code> matches all items that are in a (sub) context of foo (e.g. @foo, @foo.bar, ...) and in a (sub) project of bar.</p> <p>Note that the project matcher syntax introduces a slight ambiguity between the numeric operation <code>+</code> and the project matching. To make sure that a <code>+</code> is interpreted as the numeric operation make sure to put a space behind it (e.g. <code>5+ aNumber</code>).</p>"},{"location":"selection/#constants","title":"Constants","text":"<p>The following constants are available:</p> Constant Description it The task item that the query is currently evaluated against items The list of all task items maxInt The maximum integer value minInt The minimum integer value today todays date maxDate The maximum date value minDate The minimum date value prio* The priority *. Where * is a letter between A and Z. prioNone The priority that signals the absence of a priority"},{"location":"selection/#durations","title":"Durations","text":"<p>A duration literal follows the syntax <code>span unit</code>, where span is a (possibly negative) integer value and unit one of:</p> <ul> <li>days (or d) </li> <li>weeks (or w)</li> <li>months (or m)</li> <li>years (or y)</li> </ul> <p>Examples: <code>+5y</code>, <code>-5days</code>, ...</p>"},{"location":"selection/#functions","title":"Functions","text":"<p>A short explanation of the notation: If in the following table the function definition says for example <code>func(a: int, b: date = minDate): bool</code>,  this means that the function with the name <code>func</code> takes two arguments. The first one must be of type <code>int</code> and the second of type <code>date</code>. The second argument is optional and can be omitted. If it is omitted it will be set to <code>minDate</code>. The return type of the function is <code>bool</code>.</p> Function Description line(i: item): int The line number of i done(i: item): bool Whether or not i is already completed description(i: item): string The description of i (including all tags, projects and contexts) creation(i: item, default: date = minDate): date The creation date of i if it is set or default otherwise completion(i: item, default: date = maxDate): date The completion date of i if set or default otherwise projects(i: item): []string The projects that are present in the description of i in a list. The elements of the list do contain the leading + symbol contexts(i: item): []string The contexts that are present in the description of i in a list. The elements of the list do contain the leading @ symbol priority(i: item): priority The priority of i. If no priority is set on i <code>prioNone</code> is returned dotPrefix(s: string, prefix: string): bool Checks if s starts with all the dot delimited segments of prefix. This is useful if you want to use sub projects or contexts. Examples: <code>dotPrefix(\"+foo.bar.baz\", \"+foo.bar\") == true</code>, <code>dotPrefix(\"+foo.bar.baz\", \"+foo.b\") == false</code> substring(s: string, sub: string): bool Tests if s contains substring sub ymd(year: int, month: int, day: int): date Constructs a date from the provided year, month and day date(yyyymmdd: string, default: date = minDate): date Parses the given argument into a date (format YYYY-MM-dd). If the format does not match the default is returned tag(i: item, key: string, default: string = \"\"): string Returns the value of the first occurrence of the tag with key key. If key is not set default is returned list(l: string): []string Splits the value l at \",\". For example <code>list(\"1,2,3\")</code> becomes the list with the elements 1,2 and 3. int(num: string, default: int = 0): int Parses num as an integer. If num is not a valid integer default is returned shell(i: item, cmd: string): string Runs cmd using bash. See (shell and command) command(i: item, cmd: string): string Same as shell, but runs the cmd directly without bash"},{"location":"selection/#shell-and-command","title":"Shell and Command","text":"<p>If you want to write really exotic queries you can resort to shell and command, but be aware that using these functions comes with a high performance penalty. The way this works is that the command will receive a json representation of the specified task (like the one you get with <code>--json</code>) on stdin. Whatever is output on stdout will then be space trimmed and returned.</p> <p>Example (Match all tasks that were created during full moon): <pre><code>int(shell(\"jq -r .creation\\ \\|\\ sub\\(\\\"-\\\"\\;\\\"\\\"\\;\\\"g\\\"\\)+\\\"00\\\" | xargs pom | sed s/\\[^0-9\\]//g\"), 0) &gt;= 94\n</code></pre></p> <p>As you can see in the above example, properly escaping the string is not fun. Therefore I would recommend to always put the command in a separate file and  then use the <code>command</code> function instead.</p>"},{"location":"selection/#macros","title":"Macros","text":"<p>Macros are a way to give a name to parts of your query so that your queries can be reused and look cleaner. A simple macro definition in your <code>config.toml</code> might look like this:</p> <pre><code># Use \"after\" and \"id\" tags to express dependencies between tasks\n[[macro]]\nname = \"blocked\" # How you would like to call your macro\nargs = [\"item\"]  # The types of arguments that the macro expects. The parameters will be available as arg0, arg1, ...\nresult = \"bool\"  # The return type of this macro\nquery = '!(tag(arg0, \"after\", \"\") == \"\") &amp;&amp; (exists pre in items: tag(pre, \"id\", \"\") == tag(arg0, \"after\") &amp;&amp; !done(pre))'\ninject-it = true # Whether or not a missing item parameter should default to \"it\". Because this is true we can just write \"blocked\" instead of \"blocked(it)\"\n</code></pre> <p>Note that if you reference other macros from within your macro definition, the other macros must appear before this definition in your config file.</p> <p>With this definition in place you can then write queries like: <code>!done &amp;&amp; !blocked</code> to find not completed tasks that are not blocked.</p>"},{"location":"selection/#a-word-on-performance","title":"A Word on Performance","text":"<p>Since QQL is effectively a (brute-force) model checker for first-order logic (which is a PSPACE-Complete problem) the performance  of running your query may theoretically be extremely bad.  But unless you are dealing with a massive todo file or nest your quantifiers miles deep you will probably be fine.  If for whatever reason you are facing performance issues anyway here are a few things you can do:</p> <ol> <li>Use <code>quest archive</code>. This will move your completed tasks to a separate file and will therefore reduce the number of tasks that need to be checked against your query.</li> <li>Make use of short-circuiting by moving the expensive operations (e.g. quantification over large collections) to the end of your query. For example <code>!done(it) &amp;&amp; expensiveMacro(it)</code> could be significantly faster than <code>expensiveMacro(it) &amp;&amp; !done(it)</code>, because in the former case <code>expensiveMacro(it)</code> will only be checked on tasks that are not done.</li> <li>Do not use <code>shell</code> or <code>command</code> functions if at all possible. These operations are not only asymptotically slow, but are actually slow in practice. So if you can, avoid using them. Otherwise refer to point 2.</li> </ol>"},{"location":"styling/","title":"Styling","text":"<p>You can define styles on two levels: line level or tag level. Line level styles are defined in the main section of your config file like this:</p> <pre><code>styles = [\n    { if = 'priority &gt;= prioC', fg = \"3\" },\n]\n</code></pre> <p>This would change the foreground color of the whole line to color 3 if the corresponding task has a priority larger than C.</p> <p>Tag styles on the other hand are defined within a tag definition:</p> <pre><code>[tags.due]\ntype = \"date\"\nhumanize = true\nstyles = [\n    { if = 'date(tag(it, \"due\"), maxDate) &lt;= today + 1d', fg = \"1\" },\n]\n</code></pre> <p>This will color only the due tag column in color 1 if the task is due today or tomorrow.</p> <p>If multiple style definitions match an item, the first match will be applied.  If a line style matches it will always override any tag style.</p> <p>Colors can be either defined by using the ANSI color or with the 3 byte hex RGB color (e.g. #00FF00).</p>"},{"location":"tag-expansions/","title":"Tag Expansions","text":"<p>By default Quest does not make any assumptions about what tags you use. You can, however, choose to tell quest more about that to get some extra benefits like validation and tag expansion.</p> <p>For example to configure a tag for the <code>due</code> date you would put the following lines in your <code>config.toml</code> <pre><code>[tags.due]\ntype = \"date\"\n</code></pre></p> <p>Now quest will not only validate that the the value of <code>due</code> is a valid date, but it will also allow you to write things like <code>quest add Clean the stables due:tomorrow</code>, which will expand <code>tomorrow</code> to the date of tomorrow before writing to your todo.txt.</p> <p>The available options in a <code>[tags.my-tag]</code> section are:</p> Option Description type One of <code>date</code>, <code>int</code>, <code>duration</code> or <code>string</code>. This decides which validations apply and which tag expansions can be used. The \"string\" type does not have validation or any expansion. humanize When this tag is displayed in a column it will be printed in human friendly format (currently this only has an effect with the date type) styles A list of style definitions that apply only to this tag (see Styling)"},{"location":"tag-expansions/#int-type","title":"Int Type","text":"<p>When the <code>int</code> type is configured the validation will make sure that the value provided with the tag is a valid integer value (positive or negative). The tag value can also be of the form <code>base[+-]x</code> where <code>x</code> is a valid integer and <code>base</code> is one of <code>min</code>,<code>max</code>,<code>pmin</code>,<code>pmax</code>.</p> <p><code>min</code> (<code>max</code>) will be replaced with the minimum (maximum) integer value that is currently present on that tag on any task.  <code>pmin</code> (<code>pmax</code>) will be replaced with the minimum (maximum) integer value that is currently present on that tag on any task that shares at least one project. </p> <p>If you change the tag of multiple tasks to a <code>min</code>,<code>max</code>,<code>pmin</code>,<code>pmax</code> at once the values should be considered undefined,  because the order in which the tasks are processed is undefined.</p>"},{"location":"tag-expansions/#date-type","title":"Date Type","text":"<p>When the <code>date</code> tag is configured the validation will make sure that the value provided is a valid date of the format <code>YYYY-MM-dd</code>. Strings of the form <code>[base][+-]duration</code> or <code>base</code> will be expanded to the appropriate date (e.g. <code>tomorrow-2d</code> will get expanded to the date of yesterday).</p> <p><code>Base</code> can be one of today, tomorrow, monday, tuesday, wednesday, thursday, friday, saturday, sunday and <code>duration</code> is a valid duration as defined by QQL</p> <p>When the date type is used with the <code>humanize</code> option, dates are printed like \"in 2 days\", instead of the full <code>YYYY-MM-dd</code> format</p>"},{"location":"tag-expansions/#duration-type","title":"Duration Type","text":"<p>When the duration type is set Quest will check if the tag value is a valid duration according to QQL.</p>"},{"location":"tracking/","title":"Time Tracking","text":"<p>Time tracking in Quest is delegated to your local installation of Timewarrior. To enable time tracking you have to:</p> <ol> <li>Tell Quest which tag to use to be able to remember what currently is being tracked.</li> <li>Have Timewarrior installed.</li> </ol> <p>The following config snippet will set the tracking tag to <code>tr</code>:</p> <pre><code>[tracking]\ntag = \"tr\"\n</code></pre>"},{"location":"tracking/#starting-a-task","title":"Starting a task","text":"<p>First make sure that Timewarrior is installed. You can verify that Quest can find it by running: <code>quest version</code>.</p> <p>You can now set the <code>tr</code> tag on a task to any value you like. For example:</p> <p><pre><code>quest set tr:active on 42\n</code></pre> The actual value does not matter, it is only important that Quest notices a change in the value of the tag. After that you will notice that Timewarrior will have started tracking task 42 by using the projects, contexts and the description (without any projects/contexts/tags) as tags:</p> <pre><code>~ \u276f timew\nTracking \"Add tracking chapter\" +quest\n  Started 2024-03-07T10:55:04\n  Current            11:01:17\n  Total               0:06:13\n</code></pre> <p>For convenience there is also the <code>track</code> view command. Which effectively also just sets the tracking tag, but additionally it makes sure that only one task matches your selection (setting the tracking tag on multiple tasks will start tracking a task, but it is undefined which one). The <code>track</code> command is also much more convenient, because it doesn't make you think about a value for the tracking tag, but it just sets it to a timestamp (minutes since epoch). Therefore we could have started tracking like this as well: <pre><code>quest track 42\n</code></pre></p>"},{"location":"tracking/#changing-an-actively-tracked-task","title":"Changing an actively tracked task","text":"<p>Sometimes you might need to change the currently tracked task for whatever reason (spelling mistakes, missing project...). In this case you can just edit the task as you normally would for example using set: <pre><code>quest set @work on 42\n</code></pre> After that you will notice that this change was automatically passed on to Timewarrior:</p> <pre><code>~ \u276f timew\nTracking \"Add tracking chapter\" +quest @work\n  Started 2024-03-07T10:55:04\n  Current            11:12:18\n  Total               0:17:14\n</code></pre> <p>Note that in order to not interfere with tasks you track with Timewarrior without using Quest this only works if the current Timewarrior tags exactly match the previous state of the task. Therefore, if you manually run <code>timew start ...</code> or <code>timew tag ....</code> the currently active tracking will be considered unrelated to a Quest task.</p>"},{"location":"tracking/#stopping-a-task","title":"Stopping a task","text":"<p>To stop tracking a task you have several options.</p> <p>The easiest method is to simply run <code>timew stop</code>. In this case the tracking tag will remain on the previously tracked task. This is fine though, because it will be cleared when you start tracking another task. One thing to keep in mind is that if you want to restart  tracking on a task where the tracking tag is already set you'll have to set it to a different value. If you just use <code>track</code> to start tracking this will be handled for you.</p> <p>Another option is to clear the tracking tag: <code>quest unset tr on 42</code>.</p> <p>And the last option is to complete the item, which also automatically stops tracking: <code>quest complete 42</code>.</p> <p>For the purpose of stopping a task it is also very convenient to have a macro at hand that matches the task that is actively being tracked. For example:</p> <pre><code>[[macro]]\nname = \"tracked\"\nargs = [\"item\"]\nresult = \"bool\"\nquery = '!done(arg0) &amp;&amp; !(tag(arg0, \"tr\") == \"\")'\ninject-it = true\n</code></pre> <p>Now <code>quest complete tracked</code> will also do the trick.</p>"},{"location":"tracking/#configuring-timewarrior-tags","title":"Configuring Timewarrior tags","text":"<p>By default Quest uses projects, contexts and the description without any projects/context/tags as Timewarrior tags. As of now this is not configurable. What you can configure is whether or not project/context prefixes should be passed to Timewarrior.</p> <pre><code>[tracking]\ntag = \"tr\"\ntrim-project-prefix = true \ntrim-context-prefix = true\n</code></pre> <p>In that case the previous example would have looked like this:</p> <pre><code>~ \u276f timew\nTracking \"Add tracking chapter\" quest work\n  Started 2024-03-07T10:55:04\n  Current            11:12:18\n  Total               0:17:14\n</code></pre> <p>You can also configure which todo.txt tag should be included as Timewarrior tags.  This is useful when you want to include some metadata like a ticket id.</p> <pre><code>[tracking]\ntag = \"tr\"\ninclude-tags = [\"ticket\"]\n</code></pre>"},{"location":"views/","title":"Views","text":"<p>In Quest there are two types of commands: global commands (e.g. open and init) and view commands (e.g. set and edit). View commands run in the context of a view and global commands do not. The purpose of a view is to make it more convenient to work with subsets of your todo.txt by defining a query, sort order and other options that apply to all view commands that  run in the context of the view.</p> <p>For example you might want to consider items with the @inbox context as inbox items.</p> <p>In that case to list all the inbox items you can run:</p> <pre><code>quest -q '!done &amp;&amp; @inbox'\n</code></pre> <p>Note that by default the output will also show a contexts column, which is irrelevant to  us, because we already know that the items have the @inbox context. We can therefore specify the projection manually:</p> <pre><code>quest -q '!done &amp;&amp; @inbox' -p \"line,creation,description\"\n</code></pre> <p>Slowly this is becoming infeasible to write everytime to list your inbox. By defining a view we can make it more convenient:</p> <pre><code>[views.inbox]\nquery = '!done &amp;&amp; @inbox'\nprojection = [\"line\",\"creation\",\"description\"]\n</code></pre> <p>With this in your configuration we can now just write <code>quest inbox</code> to show the inbox. Not only that, but we can also use every view command on the subset defined by this view. A few examples:</p> <pre><code># Opens your inbox items in your editor. \n# This is very convenient to review inbox items \nquest inbox edit \n# Removes the inbox context from all items in your inbox\nquest inbox unset @inbox \n# Prioritizes all inbox items as A\nquest inbox prio A\n</code></pre> <p>As you might have guest the general command structure is <code>quest [view] [view-command]</code>. If the view is omitted the view specified by the <code>[default-view]</code> section applies.</p> <p>Although it does not run any queries the <code>add</code> command is also a view command. This is because you can define an <code>add-prefix</code> and <code>add-suffix</code> in a view. This is useful, because when running <code>quest inbox add foo</code> you would expect  \"foo\" to actually show up in your inbox, but it does not, because it does not  have the appropriate contexts. With <code>add-suffix</code> your can fix this (within limitations) by defining a string that is appended to every item added through the view. By setting this to <code>@inbox</code> you create the illusion of actually adding to the inbox.</p> <p>To read about all the available view options checkout the config reference.</p>"}]}